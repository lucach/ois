\usepackage{xcolor}
\usepackage{afterpage}
\usepackage{pifont,mdframed}
\usepackage[bottom]{footmisc}

\makeatletter
\gdef\this@inputfilename{input.txt}
\gdef\this@outputfilename{output.txt}
\makeatother

\newcommand{\inputfile}{\texttt{input.txt}}
\newcommand{\outputfile}{\texttt{output.txt}}

\newenvironment{warning}
  {\par\begin{mdframed}[linewidth=2pt,linecolor=gray]%
    \begin{list}{}{\leftmargin=1cm
                   \labelwidth=\leftmargin}\item[\Large\ding{43}]}
  {\end{list}\end{mdframed}\par}

	William \`e stato incaricato di abbattere una serie di $N$ muri disposti lungo una linea per fare posto a una nuova strada. Non avendo la patente, per farlo si \`e procurato un nuovissimo esemplare di \emph{SmartRuspa} in grado di svolgere tutto il lavoro da sola! In particolare, la SmartRuspa \`e stata posizionata dagli addetti in una certa coordinata $X$ con un certo orientamento, verso destra (coordinate crescenti) o verso sinistra (coordinate decrescenti). Da l\`i la ruspa parte e procede fino a quando non incontra un muro da abbattere. Dopo aver abbattuto un muro, inverte automaticamente la marcia e prosegue nel suo algoritmo.

	Informatosi sui blog competenti, William \`e conscio del difetto di queste ruspe di partire ad un certo punto in una direzione verso l'infinito (o peggio, verso la casa del vicino). Per prevenire onerose richieste di danni, vuole quindi trovarsi pronto a saltare sulla ruspa per spegnerla non appena vede che sta per uscire dai confini prestabiliti. Deve tuttavia decidere se posizionarsi sul confine di destra o in quello di sinistra. Aiuta William calcolando da quale direzione la ruspa uscir\`a al termine del suo algoritmo!

\Implementation
Dovrai sottoporre esattamente un file con estensione \texttt{.c}, \texttt{.cpp} o \texttt{.pas}.

\begin{warning}
Tra gli allegati a questo task troverai un template (\texttt{ruspa.c}, \texttt{ruspa.cpp}, \texttt{ruspa.pas}) con un esempio di implementazione da completare.
\end{warning}

Se sceglierai di utilizzare il template, dovrai implementare le seguenti funzioni:
\begin{center}\begin{tabularx}{\textwidth}{|c|X|}
\hline
C/C++  & \verb|void inizia(int N, int M[]);|\\
\hline
Pascal & \verb|procedure inizia(N: longint; var M: array of longint);|\\
\hline
\end{tabularx}\end{center}
In cui:
\begin{itemize}[nolistsep]
  \item L'intero $N$ rappresenta il numero di muri.
  \item L'array \texttt{M}, indicizzato da $0$ a $N-1$, contiene le coordinate dei muri in ordine crescente.
\end{itemize}

\begin{center}\begin{tabularx}{\textwidth}{|c|X|}
\hline
C/C++  & \verb|int abbatti(int X, int D);|\\
\hline
Pascal & \verb|function abbatti(X, D: longint): longint;|\\
\hline
\end{tabularx}\end{center}
In cui:
\begin{itemize}[nolistsep]
  \item L'intero $X$ rappresenta la coordinata in cui la ruspa \`e stata posizionata.
  \item L'intero $D$ rappresenta la direzione (o l'orientamento) verso cui la ruspa \`e stata posizionata: vale \texttt{0} se è verso destra e \texttt{1} se è verso sinistra.
  \item La funzione dovrà restituire l'orientamento finale della ruspa (secondo la medesima convenzione precedente), che verrà stampato sul file di output.
\end{itemize}

Il template chiamer\`a prima la procedura \texttt{inizia}, e poi $T$ volte la funzione \texttt{abbatti} di cui stamper\`a l'output. Ogni esecuzione di \texttt{abbatti} si svolge sugli stessi muri indipendentemente dalle precedenti (i muri abbattuti durante la prima esecuzione non sono da contare come gi\`a abbattuti per la seconda).


\InputFile
Il file \inputfile{} è composto da $T+2$ righe. La prima riga contiene i due interi $N$ e $T$. La seconda riga contiene gli $N$ interi $M_i$ separati da uno spazio. Le successive $T$ righe contengono ciascuna due interi $X$ e $D$, che descrivono una chiamata ad \texttt{abbatti}.

\OutputFile
Il file \outputfile{} è composto da un'unica riga contenente $T$ valori $0$ (se la ruspa termina verso destra) o $1$ (se termina verso sinistra).

% Assunzioni
\Constraints
\begin{itemize}[nolistsep, itemsep=2mm]
	\item $1 \le N, T \le 100\,000$.
	\item $-1\,000\,000 \le M_i \le 1\,000\,000$ per ogni $i=0\ldots N-1$ e sono in ordine \emph{strettamente} crescente.
	\item $0 \le D \le 1$ per ogni chiamata ad \texttt{abbatti}.
	\item $-1\,000\,000 \le X \le 1\,000\,000$ non coincide mai con la posizione di un muro.
\end{itemize}

\Scoring
Il tuo programma verrà testato su diversi test case raggruppati in subtask.
Per ottenere il punteggio relativo ad un subtask, è necessario risolvere
correttamente tutti i test relativi ad esso.

\begin{itemize}[nolistsep,itemsep=2mm]
  \item \textbf{\makebox[2cm][l]{Subtask 1} [10 punti]}: Casi d'esempio.
  \item \textbf{\makebox[2cm][l]{Subtask 2} [20 punti]}: $N, T \leq 10$.
  \item \textbf{\makebox[2cm][l]{Subtask 3} [40 punti]}: $N \leq 10\,000$, $T \leq 100$.
  \item \textbf{\makebox[2cm][l]{Subtask 4} [30 punti]}: Nessuna limitazione specifica.
\end{itemize}

% Esempi


\Examples
\begin{example}
\exmpfile{ruspa.input0.txt}{ruspa.output0.txt}%
\exmpfile{ruspa.input1.txt}{ruspa.output1.txt}%
\end{example}

\pagebreak

\Explanation
Nel \textbf{primo caso di esempio}, la ruspa abbatte prima il muro in posizione $20$, poi quello in posizione $0$ e infine esce sulla destra.\\[2mm]
Nel \textbf{secondo caso di esempio}, nei primi due test la ruspa abbatte tutti i muri uscendo nella direzione con cui era partita. Nell'ultimo test, abbatte per ultimo il muro in posizione $-1$ uscendo a destra e lasciando in piedi il muro in posizione $-3$.
