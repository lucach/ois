\usepackage{xcolor}
\usepackage{afterpage}
\usepackage{pifont,mdframed}
\usepackage[bottom]{footmisc}

\makeatletter
\gdef\this@inputfilename{input.txt}
\gdef\this@outputfilename{output.txt}
\makeatother

\newcommand{\inputfile}{\texttt{input.txt}}
\newcommand{\outputfile}{\texttt{output.txt}}

\newenvironment{warning}
  {\par\begin{mdframed}[linewidth=2pt,linecolor=gray]%
    \begin{list}{}{\leftmargin=1cm
                   \labelwidth=\leftmargin}\item[\Large\ding{43}]}
  {\end{list}\end{mdframed}\par}

William sta di nuovo giocando a Super Marco 64, e stavolta per superare il livello deve raccogliere il maggior numero possibile di monete. Il livello è composto da una serie di piattaforme collegate tra loro. Su ciascuna piattaforma possono esserci delle monete e, appena Super Marco raggiunge una certa piattaforma, raccoglie istantaneamente tutte le monete che essa contiene.

Data la mappa del livello, e sapendo che Super Marco si trova nella piattaforma $0$, determina quante monete al massimo è possibile raccogliere.

\Implementation
Dovrai sottoporre esattamente un file con estensione \texttt{.c}, \texttt{.cpp} o \texttt{.pas}.

\begin{warning}
Tra gli allegati a questo task troverai un template (\texttt{monete.c}, \texttt{monete.cpp}, \texttt{monete.pas}) con un esempio di implementazione da completare.
\end{warning}

Se sceglierai di utilizzare il template, dovrai implementare la seguente funzione:
\begin{center}\begin{tabularx}{\textwidth}{|c|X|}
\hline
C/C++  & \verb|int raccogli(int N, int M, int monete[], int A[], int B[]);|\\
\hline
Pascal & \verb|function raccogli(N, M: longint; var monete, A, B: array of longint): longint;|\\
\hline
\end{tabularx}\end{center}
In cui:
\begin{itemize}[nolistsep]
  \item Gli interi $N$ ed $M$ rappresentano rispettivamente il numero di piattaforme ed il numero di collegamenti tra di esse.
  \item L'array \texttt{monete}, indicizzato da $0$ a $N-1$, contiene il numero di monete che si trovano in ciascuna piattaforma.
  \item Gli array \texttt{A} e \texttt{B}, indicizzati da $0$ a $M-1$, identificano una coppia di piattaforme \texttt{A[i]} e \texttt{B[i]} per le quali esiste un collegamento diretto.
  \item La funzione dovrà restituire il massimo numero di monete che si possono raccogliere in totale. Tale numero verrà stampato sul file di output.
\end{itemize}

\InputFile
Il file \inputfile{} è composto da due righe. La prima riga contiene i due interi $N$ e $M$ separati da uno spazio. La seconda riga contiene gli $N$ interi \texttt{monete[i]} separati da spazi. Ciascuna delle successive $M$ righe contiene una coppia di interi \texttt{A[i]} e \texttt{B[i]}.

\OutputFile
Il file \outputfile{} è composto da un'unica riga contenente un unico intero, la risposta a questo problema.

% Assunzioni
\Constraints
\begin{itemize}[nolistsep, itemsep=2mm]
  \item $1 \le N \le 10\,000$.
  \item $0 \le M \le 100\,000$.
  \item I collegamenti sono bidirezionali.
  \item $0 \le$ \texttt{monete[i]} $\le 1000$ per ogni $i=0\ldots N-1$.
  \item $0 \le$ \texttt{A[i]}, \texttt{B[i]} $\le N-1$.
  \item \texttt{A[i]} $\ne$ \texttt{B[i]} e non ci sono collegamenti duplicati.
\end{itemize}

\Scoring
Il tuo programma verrà testato su diversi test case raggruppati in subtask.
Per ottenere il punteggio relativo ad un subtask, è necessario risolvere
correttamente tutti i test relativi ad esso.

\begin{itemize}[nolistsep,itemsep=2mm]
  \item \textbf{\makebox[2cm][l]{Subtask 1} [10 punti]}: Casi d'esempio.
  \item \textbf{\makebox[2cm][l]{Subtask 2} [30 punti]}: Il grafo è connesso (tutte le piattaforme sono raggiungibili).
  \item \textbf{\makebox[2cm][l]{Subtask 3} [30 punti]}: Tutte le piattaforme hanno esattamente $1$ moneta.
  \item \textbf{\makebox[2cm][l]{Subtask 4} [30 punti]}: Nessuna limitazione specifica.
\end{itemize}

% Esempi


\Examples
\begin{example}
\exmpfile{monete.input0.txt}{monete.output0.txt}%
\exmpfile{monete.input1.txt}{monete.output1.txt}%
\end{example}


\Explanation
Nel \textbf{primo caso di esempio} si può raccogliere immediatamente una moneta, dopodiché è possibile raggiungere la piattaforma $2$ raccogliendo un'altra moneta, per poi tornare indietro e recarsi alla piattaforma $3$ che ha ben due monete. In totale possiamo raccogliere quindi $4$ monete. Purtroppo non c'è alcun modo di raggiungere le piattaforme $1$ e $4$.\\[2mm]
Nel \textbf{secondo caso di esempio} c'è una sola piattaforma e non è possibile quindi spostarsi.
